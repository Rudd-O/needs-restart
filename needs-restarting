#!/usr/bin/env python
# -*- coding: utf-8 -*-

import collections
import errno
import glob
import os
import re
import subprocess
import sys
import tempfile


class DBusError(subprocess.CalledProcessError):
    def __init__(self, returncode, cmd, output=None, erroutput=None):
        subprocess.CalledProcessError.__init__(self, returncode, cmd, output)
        self.erroutput = erroutput
    def __str__(self):
        return "Command '%s' returned non-zero exit status %d with stderr %r" % (self.cmd, self.returncode, self.erroutput)


def unit_name(pid):
    """Get the systemd unit name associated with the PID.  Returns None
    if no unit associated, or no Python D-Bus support on this system."""
    env = dict(os.environ)
    env["LANG"] = "C"

    cmd = [
        "dbus-send",
        "--print-reply=literal",
        "--system",
        "--dest=org.freedesktop.systemd1",
        "/org/freedesktop/systemd1",
        "org.freedesktop.systemd1.Manager.GetUnitByPID",
        "uint32:%d"%pid,
    ]
    errfile = tempfile.TemporaryFile()
    try:
        out = subprocess.check_output(cmd, stderr=errfile, env=env)
    except subprocess.CalledProcessError, e:
        errfile.seek(0,0)
        errdata = errfile.read()
        if e.returncode == 1:
            if "does not belong to any loaded unit" in errdata:
                return None
        raise DBusError(e.returncode, e.cmd, e.output, errdata)
    finally:
        errfile.close()

    unit_path = out.strip()

    cmd = [
        "dbus-send",
        "--print-reply=literal",
        "--system",
        "--dest=org.freedesktop.systemd1",
        unit_path,
        "org.freedesktop.DBus.Properties.Get",
        "string:org.freedesktop.systemd1.Unit",
        "string:Id",
    ]
    errfile = tempfile.TemporaryFile()
    try:
        out = subprocess.check_output(cmd, stderr=errfile, env=env)
    except subprocess.CalledProcessError, e:
        errfile.seek(0,0)
        errdata = errfile.read()
        raise DBusError(e.returncode, e.cmd, e.output, errdata)
    finally:
        errfile.close()

    return re.sub(" +variant +", "", out.rstrip())

def has_changed(filename, old_inode):
    """Given a path name, and an old inode, will return (False, old_inode)
    if the file has not changed on disk, or (True, new_inode) if it has
    or (True, None) if the file was deleted."""
    try:
        stres = os.stat(filename)
    except OSError, e:
        if e.errno == errno.ENOENT:
            return True, None
        raise
    if stres.st_ino != old_inode:
        return True, stres.st_ino
    return False, old_inode

def get_process_info(pid):
    contents = file("/proc/%d/cmdline" % pid).read().split('\0')
    return " ".join(contents).replace("\n", " ")

def memoize(f, cache):
    def g(*args):
        if args in cache:
            return cache[args]
        r = f(*args)
        cache[args] = r
        return r
    return g

def splitinodepath(buf):
    inode = []
    buf = iter(buf)
    for character in buf:
        if character == ' ':
           break
        inode.append(character)
    inode = int("".join(inode))
    for character in buf:
        if character != ' ':
            break
    if character != '':
        path = [character]
        for character in buf:
            path.append(character)
        path = "".join(path[:-1])
    else:
        path = ""
    return inode, path

def get_needs_restarting(ignore_prefixes=None):
    """Gets list of processes that need restarting, each with its reasons.

    Args:
        ignore_prefixes: iterable of path prefixes to ignore in the analysis
    """
    if ignore_prefixes is None:
        ignore_prefixes = []
    else:
        ignore_prefixes = list(ignore_prefixes)

    cache = dict()
    hc = memoize(has_changed, cache)
    needs_restarting = collections.OrderedDict()
    for mapfile in glob.glob("/proc/*/maps"):
        try:
            pid = int(mapfile.split("/")[2])
        except ValueError:
            continue

        maps = (
            (x[1], splitinodepath(x[4]))
            for x in (
                x.split(" ", 4)
                for x in open(mapfile)
                if x )
            if "x" in x[1]
        )
        map_to_inode = collections.OrderedDict(
            (x[1][1], x[1][0])
            for x in maps
            if int(x[1][0]) > 0
            and not x[1][1].startswith("[")
            and not any(x[1][1].startswith(p) for p in ignore_prefixes)
        )
        for name, inode in map_to_inode.iteritems():
            if name.endswith(" (deleted)") and not os.path.exists(name):
                name = name[:-10]
            if pid in needs_restarting and name in needs_restarting[pid]:
                continue
            changed, new_inode = hc(name, inode)
            if changed:
                if pid not in needs_restarting:
                    needs_restarting[pid] = collections.OrderedDict()
                if new_inode is None:
                    needs_restarting[pid][name] = "was deleted"
                else:
                    needs_restarting[pid][name] = (
                        "changed inode from %s to %s" % (inode, new_inode)
                    )
    return needs_restarting

def aggregate_by_systemd_service(needs_restarting):
    by_service = collections.OrderedDict()
    for pid, files in needs_restarting.items():
        unitname = unit_name(pid)
        if unitname not in by_service:
            by_service[unitname] = []
        by_service[unitname].append((pid, files))
    return by_service

def main():
    try:
        rows, columns = subprocess.check_output(['stty', 'size'], stderr=open(os.devnull, "w")).split()
        columns = int(columns)
    except CalledProcessError:
        columns = None
    needs_restarting = get_needs_restarting()
    by_service = aggregate_by_systemd_service(needs_restarting)
    for service, processes in by_service.items():
        if service is None:
            service = "(no unit)"
        print "* unit: %s" % service
        for pid, files in processes:
            print "  * PID:", pid
            cmd = get_process_info(pid)
            line = "    command: %s" % cmd
            if columns is not None and len(line) > columns:
                line = line[:columns-3] + "..."
            print line
            for f, reason in files.iteritems():
                print "    *", f, reason

if __name__ == "__main__":
    main()
